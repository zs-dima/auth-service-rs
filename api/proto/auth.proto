syntax = "proto3";

package auth.v1;
option go_package = "auth-service/proto/auth/v1;authv1";

import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

import "google/api/annotations.proto";
import "validate/validate.proto";

import "core.proto";

// =============================================================================
// Auth Service - Authentication, MFA, OAuth, Sessions
// =============================================================================
//
// OWASP Authentication Cheat Sheet compliance:
// - Multi-identifier (email, phone)
// - MFA support (blocks 99.9% of automated attacks)
// - OAuth 2.0 with PKCE
// - Account lockout (brute-force protection)
// - Generic error messages (prevent enumeration)
// - Password change requires current password
//
// Core flows:
//   Registration: SignUp → (optional) ConfirmVerification → Active account
//   Login:        Authenticate → (if MFA) VerifyMfa → Tokens issued
//   Password:     ChangePassword (has password) | RecoveryStart/Confirm
//   (forgot/none)
//
// Expansion points:
// - Passkeys/WebAuthn: Add MFA_METHOD_PASSKEY
// - Magic links: Add RequestMagicLink, VerifyMagicLink
// - Trusted devices: TrustDevice, Skip MFA on known devices
// - Audit logging: Add audit metadata fields
// - Rate limiting hints: Return retry-after in responses
// =============================================================================
service AuthService {
  // =========================================================================
  // Authentication
  // =========================================================================

  // Authenticate with identifier (email or phone) and password
  // Returns AuthResult with tokens on success, or error status with lockout
  // info
  rpc Authenticate(AuthenticateRequest) returns (AuthResponse) {
    option (google.api.http) = {
      post: "/v1/auth/authenticate"
      body: "*"
    };
  }

  // Refresh access token using refresh token
  rpc RefreshTokens(RefreshTokensRequest) returns (TokenPair) {
    option (google.api.http) = {
      post: "/v1/auth/token/refresh"
      body: "*"
    };
  }

  // Validate current session/credentials
  rpc ValidateCredentials(ValidateCredentialsRequest)
  returns (ValidateCredentialsResponse) {
    option (google.api.http) = {
      get: "/v1/auth/credentials"
    };
  }

  // Sign out and invalidate current session
  rpc SignOut(SignOutRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/auth/signout"
      body: "*"
    };
  }

  // Register a new account
  // Returns AUTH_STATUS_SUCCESS with tokens, or AUTH_STATUS_PENDING if
  // verification required
  rpc SignUp(SignUpRequest) returns (AuthResponse) {
    option (google.api.http) = {
      post: "/v1/auth/signup"
      body: "*"
    };
  }

  // Complete MFA verification (when Authenticate returns MFA_REQUIRED)
  rpc VerifyMfa(VerifyMfaRequest) returns (AuthResponse) {
    option (google.api.http) = {
      post: "/v1/auth/mfa/verify"
      body: "*"
    };
  }

  // =========================================================================
  // OAuth 2.0 / OpenID Connect
  // =========================================================================
  // Uses DB: oauth_states (PKCE), providers (linked accounts)

  // Get OAuth authorization URL with PKCE state
  rpc GetOAuthUrl(GetOAuthUrlRequest) returns (GetOAuthUrlResponse) {
    option (google.api.http) = {
      post: "/v1/auth/oauth/url"
      body: "*"
    };
  }

  // Exchange OAuth callback code for tokens (login or register)
  rpc ExchangeOAuthCode(ExchangeOAuthCodeRequest) returns (AuthResponse) {
    option (google.api.http) = {
      post: "/v1/auth/oauth/exchange"
      body: "*"
    };
  }

  // Link OAuth provider to existing authenticated account
  rpc LinkOAuthProvider(LinkOAuthProviderRequest)
  returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/auth/oauth/link"
      body: "*"
    };
  }

  // Unlink OAuth provider from account
  rpc UnlinkOAuthProvider(UnlinkOAuthProviderRequest)
  returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/auth/oauth/providers/{provider}"
    };
  }

  // List linked OAuth providers for current user
  rpc ListLinkedProviders(ListLinkedProvidersRequest)
  returns (ListLinkedProvidersResponse) {
    option (google.api.http) = {
      get: "/v1/auth/oauth/providers"
    };
  }

  // =========================================================================
  // Password & Recovery
  // =========================================================================
  // Password operations:
  // - ChangePassword: User changes own password (requires current password -
  // OWASP)
  // - RecoveryStart/Confirm: Forgot password OR OAuth-only user adding password

  // Start password recovery (always returns success to prevent enumeration)
  // Also used by OAuth-only users to add a password to their account
  rpc RecoveryStart(RecoveryStartRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/auth/recovery/start"
      body: "*"
    };
  }

  // Confirm recovery with token and set new password
  rpc RecoveryConfirm(RecoveryConfirmRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/auth/recovery/confirm"
      body: "*"
    };
  }

  // Change password (requires current password - OWASP requirement)
  // Use RecoveryStart/Confirm if user forgot password or has no password
  // For admin password reset without verification, use UserService.SetPassword
  rpc ChangePassword(ChangePasswordRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/auth/password/change"
      body: "*"
    };
  }

  // =========================================================================
  // Email/Phone Verification
  // =========================================================================
  // Uses DB: users.email_verified, users.phone_verified
  //
  // Flow: SignUp (pending) → email/SMS sent → ConfirmVerification → tokens
  // issued RequestVerification: resend if token expired or for verified user
  // changing email/phone

  // Request verification code for email or phone (resend)
  rpc RequestVerification(RequestVerificationRequest)
  returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/auth/verification/request"
      body: "*"
    };
  }

  // Confirm verification with token - returns auth tokens for seamless login
  rpc ConfirmVerification(ConfirmVerificationRequest) returns (AuthResponse) {
    option (google.api.http) = {
      post: "/v1/auth/verification/confirm"
      body: "*"
    };
  }

  // =========================================================================
  // MFA Management
  // =========================================================================
  // Simple MFA lifecycle: GetStatus → Setup → Verify → Enable/Disable

  // Get current MFA status for user
  rpc GetMfaStatus(GetMfaStatusRequest) returns (GetMfaStatusResponse) {
    option (google.api.http) = {
      get: "/v1/auth/mfa/status"
    };
  }

  // Begin MFA setup (returns secret/challenge based on method)
  rpc SetupMfa(SetupMfaRequest) returns (SetupMfaResponse) {
    option (google.api.http) = {
      post: "/v1/auth/mfa/setup"
      body: "*"
    };
  }

  // Confirm MFA setup with verification code
  rpc ConfirmMfaSetup(ConfirmMfaSetupRequest)
  returns (ConfirmMfaSetupResponse) {
    option (google.api.http) = {
      post: "/v1/auth/mfa/setup/confirm"
      body: "*"
    };
  }

  // Disable MFA (requires password verification)
  rpc DisableMfa(DisableMfaRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/auth/mfa/disable"
      body: "*"
    };
  }

  // =========================================================================
  // Sessions
  // =========================================================================

  // List all active sessions for current user
  // POST because refresh_token in body must not appear in URLs/logs
  rpc ListSessions(ListSessionsRequest) returns (ListSessionsResponse) {
    option (google.api.http) = {
      post: "/v1/auth/sessions"
      body: "*"
    };
  }

  // Revoke a specific session by device_id
  rpc RevokeSession(RevokeSessionRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/auth/sessions/{device_id}"
    };
  }

  // Revoke all sessions except current
  rpc RevokeOtherSessions(RevokeOtherSessionsRequest)
  returns (RevokeSessionsResponse) {
    option (google.api.http) = {
      post: "/v1/auth/sessions/revoke-others"
      body: "*"
    };
  }
}

// =============================================================================
// ENUMS
// =============================================================================

// Type of identifier for authentication
// Maps to DB: `users.email` (email domain), `users.phone` (`phone_e164` domain)
enum IdentifierType {
  IDENTIFIER_TYPE_UNSPECIFIED =
      0; // Auto-detect based on format (@ = email, + = phone)
  IDENTIFIER_TYPE_EMAIL = 1; // Email address
  IDENTIFIER_TYPE_PHONE = 2; // Phone number in E.164 format (+1234567890)
}

// OAuth providers - matches DB enum: oauth_provider
enum OAuthProvider {
  OAUTH_PROVIDER_UNSPECIFIED = 0;
  OAUTH_PROVIDER_GOOGLE      = 1;
  OAUTH_PROVIDER_GITHUB      = 2;
  OAUTH_PROVIDER_MICROSOFT   = 3;
  OAUTH_PROVIDER_APPLE       = 4;
  OAUTH_PROVIDER_FACEBOOK    = 5;
}

// Authentication result status
enum AuthStatus {
  AUTH_STATUS_UNSPECIFIED  = 0;
  AUTH_STATUS_SUCCESS      = 1; // Fully authenticated, tokens provided
  AUTH_STATUS_MFA_REQUIRED = 2; // First factor passed, MFA verification needed
  AUTH_STATUS_FAILED       = 3; // Invalid credentials (generic - OWASP)
  AUTH_STATUS_LOCKED       = 4; // Account temporarily locked (see lockout_info)
  AUTH_STATUS_SUSPENDED    = 5; // Account suspended by admin
  AUTH_STATUS_PENDING      = 6; // Account pending verification
}

// Verification type for email/phone
enum VerificationType {
  VERIFICATION_TYPE_UNSPECIFIED = 0;
  VERIFICATION_TYPE_EMAIL       = 1;
  VERIFICATION_TYPE_PHONE       = 2;
}

// MFA method types - extensible for future methods
enum MfaMethod {
  MFA_METHOD_UNSPECIFIED   = 0;
  MFA_METHOD_TOTP          = 1; // Time-based OTP (RFC 6238) - authenticator apps
  MFA_METHOD_SMS           = 2; // SMS OTP (less secure, but widely used)
  MFA_METHOD_EMAIL         = 3; // Email OTP
  MFA_METHOD_RECOVERY_CODE = 4; // One-time recovery codes
  // Future: MFA_METHOD_PASSKEY = 5; // WebAuthn/FIDO2
}

// =============================================================================
// TOKEN
// =============================================================================

message TokenPair {
  string                    access_token  = 1;
  string                    refresh_token = 2;
  google.protobuf.Timestamp expires_at    = 3;
}

// Client information sent with authentication requests
message ClientInfo {
  // Unique device/client identifier
  string device_id = 1
  [ (validate.rules).string = {min_len : 1, max_len : 255} ];

  // Human-readable device name
  string device_name = 2 [ (validate.rules).string.max_len = 255 ];

  // Device type: 'mobile', 'tablet', 'desktop', 'web', 'unknown'
  string device_type = 3 [ (validate.rules).string.max_len = 50 ];

  // App/client version
  string client_version = 4 [ (validate.rules).string.max_len = 100 ];

  // Additional metadata (`device_model`, `os_info`, fingerprint, etc.)
  map<string, string> metadata = 5; // google.protobuf.Struct metadata = 5;
}

// Info returned on successful auth
message UserSnapshot {
  core.v1.UUID           user_id          = 1;
  string                 display_name     = 2;
  string                 email            = 3;
  string                 phone            = 4; // User's phone (E.164 format)
  core.v1.UserRole       role             = 5;
  core.v1.UserStatus     status           = 6; // Account status
  bool                   email_verified   = 7; // Email verification status
  bool                   phone_verified   = 8; // Phone verification status
  bool                   mfa_enabled      = 9; // Whether MFA is enabled for this account
  repeated OAuthProvider linked_providers = 10; // Linked OAuth providers
  string                 avatar_url       = 11; // User's avatar URL
  bool                   has_password     = 12; // Whether user has a password set
}

// Account lockout information
message LockoutInfo {
  // Duration until account is unlocked
  google.protobuf.Duration retry_after = 1;

  // Number of failed attempts
  int32 failed_attempts = 2;

  // Maximum attempts before lockout (configurable)
  int32 max_attempts = 3;

  // Lockout timestamp
  google.protobuf.Timestamp locked_until = 4;
}

// MFA challenge - returned when second factor is required
message MfaChallenge {
  // Token to correlate MFA verification with original auth attempt
  string challenge_token = 1;

  // Available MFA methods for this user
  repeated MfaMethodInfo available_methods = 2;

  // Challenge expiration - typically 5 minutes
  google.protobuf.Timestamp expires_at = 3;
}

// Information about an available MFA method
message MfaMethodInfo {
  MfaMethod method = 1;

  // Masked hint (e.g., "***-***-1234" for SMS, "john***@gm***.com" for email)
  string hint = 2;

  // True if this is the user's preferred/default method
  bool is_default = 3;
}

// =============================================================================
// AUTHENTICATION
// =============================================================================

// Unified authentication request supporting multiple identifier types
message AuthenticateRequest {
  // Primary identifier (email or phone)
  string identifier = 1
  [ (validate.rules).string = {min_len : 1, max_len : 254} ];

  // Type of identifier
  IdentifierType identifier_type = 2;

  // Password (NIST: min 8 chars, check against breach databases)
  string password = 3
  [ (validate.rules).string = {min_len : 1, max_len : 128} ];

  // Installation ID for immediate session
  core.v1.UUID installation_id = 4 [ (validate.rules).message.required = true ];

  // Client info for session
  ClientInfo client_info = 5 [ (validate.rules).message.required = true ];
}

// Authentication result
// Returns tokens on success, or MFA challenge if second factor required
message AuthResponse {
  // Status of authentication attempt
  AuthStatus status = 1;

  TokenPair tokens = 2;

  UserSnapshot user = 3;

  // Populated on AUTH_STATUS_MFA_REQUIRED
  MfaChallenge mfa_challenge = 4;

  // Populated on AUTH_STATUS_LOCKED
  LockoutInfo lockout_info = 5;

  // Message for user (generic per OWASP - prevent enumeration)
  string message = 6;
}

// Register a new user account
message SignUpRequest {
  // User identifier (email or phone in E.164 format)
  string identifier = 1
  [ (validate.rules).string = {min_len : 1, max_len : 254} ];

  // Type of identifier (auto-detected if not specified based on format)
  IdentifierType identifier_type = 2;

  // Password
  string password = 3
  [ (validate.rules).string = {min_len : 8, max_len : 128} ];

  // Display name
  string display_name = 4
  [ (validate.rules).string = {min_len : 1, max_len : 255} ];

  // Unique installation/app instance ID
  core.v1.UUID installation_id = 5 [ (validate.rules).message.required = true ];

  // Client/device information for session (stored in sessions table)
  ClientInfo client_info = 6 [ (validate.rules).message.required = true ];

  // Locale (BCP 47, e.g., `en-US`)
  string locale = 7 [ (validate.rules).string.max_len = 35 ];

  // Timezone (IANA, e.g., `America/New_York`)
  string timezone = 8 [ (validate.rules).string.max_len = 64 ];

  // Client-generated idempotency key (UUID v4 recommended).
  // Guarantees at-most-once execution for retries on network failures.
  // Server ignores the request body if a matching key was already processed
  // and returns the original response.
  string idempotency_key = 9 [ (validate.rules).string.max_len = 64 ];
}

// Verify MFA code to complete authentication
message VerifyMfaRequest {
  // Challenge token from MfaChallenge
  string challenge_token = 1 [ (validate.rules).string.min_len = 1 ];

  // Method used for verification
  MfaMethod method = 2 [ (validate.rules).enum = {not_in : [ 0 ]} ];

  // Verification code (6-digit TOTP, SMS code, recovery code, etc.)
  string code = 3 [ (validate.rules).string = {min_len : 6, max_len : 32} ];

  // Client info for session creation
  ClientInfo client_info = 4;
}

message RefreshTokensRequest {
  string refresh_token = 1 [ (validate.rules).string.min_len = 1 ];
}

message ValidateCredentialsRequest {}

message ValidateCredentialsResponse {
  bool         valid = 1;
  UserSnapshot user  = 2;
}

message SignOutRequest {}

// =============================================================================
// OAUTH
// =============================================================================

// Get OAuth authorization URL
message GetOAuthUrlRequest {
  // OAuth provider
  OAuthProvider provider = 1 [ (validate.rules).enum.not_in = 0 ];

  // Optional: redirect URI override
  string redirect_uri = 2 [ (validate.rules).string.max_len = 2048 ];

  // Optional: additional scopes
  repeated string scopes = 3;

  // Optional: state data to preserve across OAuth flow
  string state_data = 4 [ (validate.rules).string.max_len = 1024 ];
}

// OAuth URL response
message GetOAuthUrlResponse {
  // Authorization URL to redirect user
  string authorization_url = 1;

  // State parameter (for CSRF protection)
  string state = 2;
}

// Exchange OAuth authorization code
message ExchangeOAuthCodeRequest {
  // Authorization code from OAuth callback
  string code = 1 [ (validate.rules).string.min_len = 1 ];

  // State parameter from callback
  string state = 2 [ (validate.rules).string.min_len = 1 ];

  // Installation ID
  core.v1.UUID installation_id = 3 [ (validate.rules).message.required = true ];

  // Client info
  ClientInfo client_info = 4 [ (validate.rules).message.required = true ];
}

// Link OAuth provider to existing account
message LinkOAuthProviderRequest {
  // Authorization code from OAuth callback
  string code = 1 [ (validate.rules).string.min_len = 1 ];

  // State parameter
  string state = 2 [ (validate.rules).string.min_len = 1 ];
}

// Unlink OAuth provider
message UnlinkOAuthProviderRequest {
  OAuthProvider provider = 1 [ (validate.rules).enum = {not_in : [ 0 ]} ];
}

message ListLinkedProvidersRequest {}

// Linked OAuth providers response
message ListLinkedProvidersResponse { repeated LinkedProvider providers = 1; }

message LinkedProvider {
  OAuthProvider             provider         = 1;
  string                    provider_user_id = 2; // Provider's user ID
  string                    email            = 3; // Email from provider (if available)
  google.protobuf.Timestamp linked_at        = 4;
}

// =============================================================================
// ACCOUNT RECOVERY
// =============================================================================
// Uses DB: password_reset_tokens table

// Start account recovery (password reset)
// Always returns success to prevent user enumeration (OWASP)
message RecoveryStartRequest {
  // Email or phone number (used to look up account)
  string identifier = 1
  [ (validate.rules).string = {min_len : 1, max_len : 254} ];

  // Identifier type (email or phone)
  IdentifierType identifier_type = 2;

  // Client-generated idempotency key (UUID v4 recommended).
  // Prevents duplicate recovery emails on network retries.
  string idempotency_key = 3 [ (validate.rules).string.max_len = 64 ];
}

// Confirm recovery and set new password
message RecoveryConfirmRequest {
  // Recovery token from email/SMS
  string token = 1 [ (validate.rules).string.min_len = 1 ];

  // New password (NIST: min 8 chars with MFA, min 15 without)
  string new_password = 2
  [ (validate.rules).string = {min_len : 8, max_len : 128} ];
}

// Change password (requires current password)
message ChangePasswordRequest {
  // Current password for verification
  string current_password = 1 [ (validate.rules).string.min_len = 1 ];

  // New password
  string new_password = 2
  [ (validate.rules).string = {min_len : 8, max_len : 128} ];
}

// =============================================================================
// EMAIL/PHONE VERIFICATION
// =============================================================================
// Uses DB: users.email_verified, users.phone_verified
// Note: Verification tokens stored in separate verification_tokens table (to be
// added)

message RequestVerificationRequest {
  // Type of verification
  VerificationType type = 1 [ (validate.rules).enum = {not_in : [ 0 ]} ];
}

message ConfirmVerificationRequest {
  // Verification token from email/SMS
  string token = 1 [ (validate.rules).string.min_len = 1 ];

  // Type of verification
  VerificationType type = 2 [ (validate.rules).enum = {not_in : [ 0 ]} ];

  // Installation ID for session creation
  core.v1.UUID installation_id = 3 [ (validate.rules).message.required = true ];

  // Client info for session (enables auto-login after verification)
  ClientInfo client_info = 4 [ (validate.rules).message.required = true ];
}

// =============================================================================
// MFA
// =============================================================================
message GetMfaStatusRequest {}

// MFA status for current user
message GetMfaStatusResponse {
  // Whether MFA is enabled
  bool enabled = 1;

  // Configured MFA methods
  repeated MfaMethodStatus methods = 2;

  // Number of unused recovery codes remaining
  int32 recovery_codes_remaining = 3;
}

// Status of a configured MFA method
message MfaMethodStatus {
  MfaMethod method  = 1;
  bool      enabled = 2;

  // Masked hint for this method
  string hint = 3;

  // When this method was configured
  google.protobuf.Timestamp configured_at = 4;
}

// Request to set up MFA
message SetupMfaRequest {
  // Method to set up
  MfaMethod method = 1 [ (validate.rules).enum.not_in = 0 ];

  // For SMS/Email: the phone/email to use (must be verified)
  string identifier = 2 [ (validate.rules).string.max_len = 254 ];
}

// MFA setup response
message SetupMfaResponse {
  // For TOTP: base32-encoded secret
  string secret = 1;

  // For TOTP: otpauth:// URI for QR code generation
  string provisioning_uri = 2;

  // For SMS/Email: masked destination where code was sent
  string masked_destination = 3;

  // Setup token to correlate with `ConfirmMfaSetup`
  string setup_token = 4;

  // Setup expires at
  google.protobuf.Timestamp expires_at = 5;
}

// Confirm MFA setup
message ConfirmMfaSetupRequest {
  // Setup token from `SetupMfaReply`
  string setup_token = 1 [ (validate.rules).string.min_len = 1 ];

  // Verification code
  string code = 2 [ (validate.rules).string = {min_len : 6, max_len : 8} ];
}

// MFA setup result
message ConfirmMfaSetupResponse {
  oneof result {
    MfaSetupSuccess success = 1;
    MfaSetupError   error   = 2;
  }
}

// Recovery codes (only returned on first MFA enrollment, display once!)
message MfaSetupSuccess { repeated string recovery_codes = 1; }

message MfaSetupError {
  string message = 1; // Error message if failed
  string code    = 2;
}

// Disable MFA request
message DisableMfaRequest {
  // Method to disable (or all if not specified)
  MfaMethod method = 1;

  // Current password for verification (OWASP: verify identity for sensitive
  // ops)
  string password = 2 [ (validate.rules).string.min_len = 1 ];
}

// =============================================================================
// SESSION MANAGEMENT
// =============================================================================

// Request to list sessions
message ListSessionsRequest {
  // Current refresh token to identify which session is active
  string refresh_token = 1 [ (validate.rules).string.min_len = 1 ];
}

// Response for listing sessions
message ListSessionsResponse { repeated SessionInfo sessions = 1; }

// Session information returned to clients
message SessionInfo {
  // Unique device identifier
  string device_id = 1;

  // Human-readable device name
  string device_name = 2;

  // Device type: 'mobile', 'tablet', 'desktop', 'web', 'unknown'
  string device_type = 3;

  // App version
  string client_version = 4;

  // Last seen IP address (may be masked for privacy)
  string ip_address = 5;

  // ISO 3166-1 alpha-2 country code
  string ip_country = 6;

  // Session creation timestamp
  google.protobuf.Timestamp created_at = 7;

  // Last activity timestamp
  google.protobuf.Timestamp last_seen_at = 8;

  // Session expiration timestamp
  google.protobuf.Timestamp expires_at = 9;

  // True if this is the current session
  bool is_current = 10;

  // IP address at session creation
  string ip_created_by = 11;

  // Number of token refreshes (activity indicator)
  int32 activity_count = 12;

  // Session metadata (user agent, fingerprint, etc.)
  map<string, string> metadata = 13; // google.protobuf.Struct metadata = 13;
}

// Request to revoke a specific session by `device_id`
message RevokeSessionRequest {
  string device_id = 1
  [ (validate.rules).string = {min_len : 1, max_len : 255} ];
}

message RevokeOtherSessionsRequest {}

// Response for revoking multiple sessions
message RevokeSessionsResponse {
  // Number of sessions revoked
  int32 revoked_count = 1;
}
